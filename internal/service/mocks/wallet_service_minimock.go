package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Sysleec/TestEWallet/internal/service.WalletService -o wallet_service_minimock.go -n WalletServiceMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sysleec/TestEWallet/internal/model"
	"github.com/gojuno/minimock/v3"
)

// WalletServiceMock implements service.WalletService
type WalletServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateWallet          func(ctx context.Context) (wp1 *model.Wallet, err error)
	inspectFuncCreateWallet   func(ctx context.Context)
	afterCreateWalletCounter  uint64
	beforeCreateWalletCounter uint64
	CreateWalletMock          mWalletServiceMockCreateWallet

	funcGetHistory          func(ctx context.Context, id string) (ta1 []model.Transfer, err error)
	inspectFuncGetHistory   func(ctx context.Context, id string)
	afterGetHistoryCounter  uint64
	beforeGetHistoryCounter uint64
	GetHistoryMock          mWalletServiceMockGetHistory

	funcGetWallet          func(ctx context.Context, id string) (wp1 *model.Wallet, err error)
	inspectFuncGetWallet   func(ctx context.Context, id string)
	afterGetWalletCounter  uint64
	beforeGetWalletCounter uint64
	GetWalletMock          mWalletServiceMockGetWallet

	funcSendMoney          func(ctx context.Context, trans *model.Transfer) (err error)
	inspectFuncSendMoney   func(ctx context.Context, trans *model.Transfer)
	afterSendMoneyCounter  uint64
	beforeSendMoneyCounter uint64
	SendMoneyMock          mWalletServiceMockSendMoney
}

// NewWalletServiceMock returns a mock for service.WalletService
func NewWalletServiceMock(t minimock.Tester) *WalletServiceMock {
	m := &WalletServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateWalletMock = mWalletServiceMockCreateWallet{mock: m}
	m.CreateWalletMock.callArgs = []*WalletServiceMockCreateWalletParams{}

	m.GetHistoryMock = mWalletServiceMockGetHistory{mock: m}
	m.GetHistoryMock.callArgs = []*WalletServiceMockGetHistoryParams{}

	m.GetWalletMock = mWalletServiceMockGetWallet{mock: m}
	m.GetWalletMock.callArgs = []*WalletServiceMockGetWalletParams{}

	m.SendMoneyMock = mWalletServiceMockSendMoney{mock: m}
	m.SendMoneyMock.callArgs = []*WalletServiceMockSendMoneyParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mWalletServiceMockCreateWallet struct {
	mock               *WalletServiceMock
	defaultExpectation *WalletServiceMockCreateWalletExpectation
	expectations       []*WalletServiceMockCreateWalletExpectation

	callArgs []*WalletServiceMockCreateWalletParams
	mutex    sync.RWMutex
}

// WalletServiceMockCreateWalletExpectation specifies expectation struct of the WalletService.CreateWallet
type WalletServiceMockCreateWalletExpectation struct {
	mock    *WalletServiceMock
	params  *WalletServiceMockCreateWalletParams
	results *WalletServiceMockCreateWalletResults
	Counter uint64
}

// WalletServiceMockCreateWalletParams contains parameters of the WalletService.CreateWallet
type WalletServiceMockCreateWalletParams struct {
	ctx context.Context
}

// WalletServiceMockCreateWalletResults contains results of the WalletService.CreateWallet
type WalletServiceMockCreateWalletResults struct {
	wp1 *model.Wallet
	err error
}

// Expect sets up expected params for WalletService.CreateWallet
func (mmCreateWallet *mWalletServiceMockCreateWallet) Expect(ctx context.Context) *mWalletServiceMockCreateWallet {
	if mmCreateWallet.mock.funcCreateWallet != nil {
		mmCreateWallet.mock.t.Fatalf("WalletServiceMock.CreateWallet mock is already set by Set")
	}

	if mmCreateWallet.defaultExpectation == nil {
		mmCreateWallet.defaultExpectation = &WalletServiceMockCreateWalletExpectation{}
	}

	mmCreateWallet.defaultExpectation.params = &WalletServiceMockCreateWalletParams{ctx}
	for _, e := range mmCreateWallet.expectations {
		if minimock.Equal(e.params, mmCreateWallet.defaultExpectation.params) {
			mmCreateWallet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateWallet.defaultExpectation.params)
		}
	}

	return mmCreateWallet
}

// Inspect accepts an inspector function that has same arguments as the WalletService.CreateWallet
func (mmCreateWallet *mWalletServiceMockCreateWallet) Inspect(f func(ctx context.Context)) *mWalletServiceMockCreateWallet {
	if mmCreateWallet.mock.inspectFuncCreateWallet != nil {
		mmCreateWallet.mock.t.Fatalf("Inspect function is already set for WalletServiceMock.CreateWallet")
	}

	mmCreateWallet.mock.inspectFuncCreateWallet = f

	return mmCreateWallet
}

// Return sets up results that will be returned by WalletService.CreateWallet
func (mmCreateWallet *mWalletServiceMockCreateWallet) Return(wp1 *model.Wallet, err error) *WalletServiceMock {
	if mmCreateWallet.mock.funcCreateWallet != nil {
		mmCreateWallet.mock.t.Fatalf("WalletServiceMock.CreateWallet mock is already set by Set")
	}

	if mmCreateWallet.defaultExpectation == nil {
		mmCreateWallet.defaultExpectation = &WalletServiceMockCreateWalletExpectation{mock: mmCreateWallet.mock}
	}
	mmCreateWallet.defaultExpectation.results = &WalletServiceMockCreateWalletResults{wp1, err}
	return mmCreateWallet.mock
}

// Set uses given function f to mock the WalletService.CreateWallet method
func (mmCreateWallet *mWalletServiceMockCreateWallet) Set(f func(ctx context.Context) (wp1 *model.Wallet, err error)) *WalletServiceMock {
	if mmCreateWallet.defaultExpectation != nil {
		mmCreateWallet.mock.t.Fatalf("Default expectation is already set for the WalletService.CreateWallet method")
	}

	if len(mmCreateWallet.expectations) > 0 {
		mmCreateWallet.mock.t.Fatalf("Some expectations are already set for the WalletService.CreateWallet method")
	}

	mmCreateWallet.mock.funcCreateWallet = f
	return mmCreateWallet.mock
}

// When sets expectation for the WalletService.CreateWallet which will trigger the result defined by the following
// Then helper
func (mmCreateWallet *mWalletServiceMockCreateWallet) When(ctx context.Context) *WalletServiceMockCreateWalletExpectation {
	if mmCreateWallet.mock.funcCreateWallet != nil {
		mmCreateWallet.mock.t.Fatalf("WalletServiceMock.CreateWallet mock is already set by Set")
	}

	expectation := &WalletServiceMockCreateWalletExpectation{
		mock:   mmCreateWallet.mock,
		params: &WalletServiceMockCreateWalletParams{ctx},
	}
	mmCreateWallet.expectations = append(mmCreateWallet.expectations, expectation)
	return expectation
}

// Then sets up WalletService.CreateWallet return parameters for the expectation previously defined by the When method
func (e *WalletServiceMockCreateWalletExpectation) Then(wp1 *model.Wallet, err error) *WalletServiceMock {
	e.results = &WalletServiceMockCreateWalletResults{wp1, err}
	return e.mock
}

// CreateWallet implements service.WalletService
func (mmCreateWallet *WalletServiceMock) CreateWallet(ctx context.Context) (wp1 *model.Wallet, err error) {
	mm_atomic.AddUint64(&mmCreateWallet.beforeCreateWalletCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateWallet.afterCreateWalletCounter, 1)

	if mmCreateWallet.inspectFuncCreateWallet != nil {
		mmCreateWallet.inspectFuncCreateWallet(ctx)
	}

	mm_params := WalletServiceMockCreateWalletParams{ctx}

	// Record call args
	mmCreateWallet.CreateWalletMock.mutex.Lock()
	mmCreateWallet.CreateWalletMock.callArgs = append(mmCreateWallet.CreateWalletMock.callArgs, &mm_params)
	mmCreateWallet.CreateWalletMock.mutex.Unlock()

	for _, e := range mmCreateWallet.CreateWalletMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp1, e.results.err
		}
	}

	if mmCreateWallet.CreateWalletMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateWallet.CreateWalletMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateWallet.CreateWalletMock.defaultExpectation.params
		mm_got := WalletServiceMockCreateWalletParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateWallet.t.Errorf("WalletServiceMock.CreateWallet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateWallet.CreateWalletMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateWallet.t.Fatal("No results are set for the WalletServiceMock.CreateWallet")
		}
		return (*mm_results).wp1, (*mm_results).err
	}
	if mmCreateWallet.funcCreateWallet != nil {
		return mmCreateWallet.funcCreateWallet(ctx)
	}
	mmCreateWallet.t.Fatalf("Unexpected call to WalletServiceMock.CreateWallet. %v", ctx)
	return
}

// CreateWalletAfterCounter returns a count of finished WalletServiceMock.CreateWallet invocations
func (mmCreateWallet *WalletServiceMock) CreateWalletAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateWallet.afterCreateWalletCounter)
}

// CreateWalletBeforeCounter returns a count of WalletServiceMock.CreateWallet invocations
func (mmCreateWallet *WalletServiceMock) CreateWalletBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateWallet.beforeCreateWalletCounter)
}

// Calls returns a list of arguments used in each call to WalletServiceMock.CreateWallet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateWallet *mWalletServiceMockCreateWallet) Calls() []*WalletServiceMockCreateWalletParams {
	mmCreateWallet.mutex.RLock()

	argCopy := make([]*WalletServiceMockCreateWalletParams, len(mmCreateWallet.callArgs))
	copy(argCopy, mmCreateWallet.callArgs)

	mmCreateWallet.mutex.RUnlock()

	return argCopy
}

// MinimockCreateWalletDone returns true if the count of the CreateWallet invocations corresponds
// the number of defined expectations
func (m *WalletServiceMock) MinimockCreateWalletDone() bool {
	for _, e := range m.CreateWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateWalletCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateWallet != nil && mm_atomic.LoadUint64(&m.afterCreateWalletCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateWalletInspect logs each unmet expectation
func (m *WalletServiceMock) MinimockCreateWalletInspect() {
	for _, e := range m.CreateWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WalletServiceMock.CreateWallet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateWalletCounter) < 1 {
		if m.CreateWalletMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WalletServiceMock.CreateWallet")
		} else {
			m.t.Errorf("Expected call to WalletServiceMock.CreateWallet with params: %#v", *m.CreateWalletMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateWallet != nil && mm_atomic.LoadUint64(&m.afterCreateWalletCounter) < 1 {
		m.t.Error("Expected call to WalletServiceMock.CreateWallet")
	}
}

type mWalletServiceMockGetHistory struct {
	mock               *WalletServiceMock
	defaultExpectation *WalletServiceMockGetHistoryExpectation
	expectations       []*WalletServiceMockGetHistoryExpectation

	callArgs []*WalletServiceMockGetHistoryParams
	mutex    sync.RWMutex
}

// WalletServiceMockGetHistoryExpectation specifies expectation struct of the WalletService.GetHistory
type WalletServiceMockGetHistoryExpectation struct {
	mock    *WalletServiceMock
	params  *WalletServiceMockGetHistoryParams
	results *WalletServiceMockGetHistoryResults
	Counter uint64
}

// WalletServiceMockGetHistoryParams contains parameters of the WalletService.GetHistory
type WalletServiceMockGetHistoryParams struct {
	ctx context.Context
	id  string
}

// WalletServiceMockGetHistoryResults contains results of the WalletService.GetHistory
type WalletServiceMockGetHistoryResults struct {
	ta1 []model.Transfer
	err error
}

// Expect sets up expected params for WalletService.GetHistory
func (mmGetHistory *mWalletServiceMockGetHistory) Expect(ctx context.Context, id string) *mWalletServiceMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("WalletServiceMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &WalletServiceMockGetHistoryExpectation{}
	}

	mmGetHistory.defaultExpectation.params = &WalletServiceMockGetHistoryParams{ctx, id}
	for _, e := range mmGetHistory.expectations {
		if minimock.Equal(e.params, mmGetHistory.defaultExpectation.params) {
			mmGetHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistory.defaultExpectation.params)
		}
	}

	return mmGetHistory
}

// Inspect accepts an inspector function that has same arguments as the WalletService.GetHistory
func (mmGetHistory *mWalletServiceMockGetHistory) Inspect(f func(ctx context.Context, id string)) *mWalletServiceMockGetHistory {
	if mmGetHistory.mock.inspectFuncGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("Inspect function is already set for WalletServiceMock.GetHistory")
	}

	mmGetHistory.mock.inspectFuncGetHistory = f

	return mmGetHistory
}

// Return sets up results that will be returned by WalletService.GetHistory
func (mmGetHistory *mWalletServiceMockGetHistory) Return(ta1 []model.Transfer, err error) *WalletServiceMock {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("WalletServiceMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &WalletServiceMockGetHistoryExpectation{mock: mmGetHistory.mock}
	}
	mmGetHistory.defaultExpectation.results = &WalletServiceMockGetHistoryResults{ta1, err}
	return mmGetHistory.mock
}

// Set uses given function f to mock the WalletService.GetHistory method
func (mmGetHistory *mWalletServiceMockGetHistory) Set(f func(ctx context.Context, id string) (ta1 []model.Transfer, err error)) *WalletServiceMock {
	if mmGetHistory.defaultExpectation != nil {
		mmGetHistory.mock.t.Fatalf("Default expectation is already set for the WalletService.GetHistory method")
	}

	if len(mmGetHistory.expectations) > 0 {
		mmGetHistory.mock.t.Fatalf("Some expectations are already set for the WalletService.GetHistory method")
	}

	mmGetHistory.mock.funcGetHistory = f
	return mmGetHistory.mock
}

// When sets expectation for the WalletService.GetHistory which will trigger the result defined by the following
// Then helper
func (mmGetHistory *mWalletServiceMockGetHistory) When(ctx context.Context, id string) *WalletServiceMockGetHistoryExpectation {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("WalletServiceMock.GetHistory mock is already set by Set")
	}

	expectation := &WalletServiceMockGetHistoryExpectation{
		mock:   mmGetHistory.mock,
		params: &WalletServiceMockGetHistoryParams{ctx, id},
	}
	mmGetHistory.expectations = append(mmGetHistory.expectations, expectation)
	return expectation
}

// Then sets up WalletService.GetHistory return parameters for the expectation previously defined by the When method
func (e *WalletServiceMockGetHistoryExpectation) Then(ta1 []model.Transfer, err error) *WalletServiceMock {
	e.results = &WalletServiceMockGetHistoryResults{ta1, err}
	return e.mock
}

// GetHistory implements service.WalletService
func (mmGetHistory *WalletServiceMock) GetHistory(ctx context.Context, id string) (ta1 []model.Transfer, err error) {
	mm_atomic.AddUint64(&mmGetHistory.beforeGetHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHistory.afterGetHistoryCounter, 1)

	if mmGetHistory.inspectFuncGetHistory != nil {
		mmGetHistory.inspectFuncGetHistory(ctx, id)
	}

	mm_params := WalletServiceMockGetHistoryParams{ctx, id}

	// Record call args
	mmGetHistory.GetHistoryMock.mutex.Lock()
	mmGetHistory.GetHistoryMock.callArgs = append(mmGetHistory.GetHistoryMock.callArgs, &mm_params)
	mmGetHistory.GetHistoryMock.mutex.Unlock()

	for _, e := range mmGetHistory.GetHistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetHistory.GetHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHistory.GetHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHistory.GetHistoryMock.defaultExpectation.params
		mm_got := WalletServiceMockGetHistoryParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHistory.t.Errorf("WalletServiceMock.GetHistory got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHistory.GetHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHistory.t.Fatal("No results are set for the WalletServiceMock.GetHistory")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetHistory.funcGetHistory != nil {
		return mmGetHistory.funcGetHistory(ctx, id)
	}
	mmGetHistory.t.Fatalf("Unexpected call to WalletServiceMock.GetHistory. %v %v", ctx, id)
	return
}

// GetHistoryAfterCounter returns a count of finished WalletServiceMock.GetHistory invocations
func (mmGetHistory *WalletServiceMock) GetHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.afterGetHistoryCounter)
}

// GetHistoryBeforeCounter returns a count of WalletServiceMock.GetHistory invocations
func (mmGetHistory *WalletServiceMock) GetHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.beforeGetHistoryCounter)
}

// Calls returns a list of arguments used in each call to WalletServiceMock.GetHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistory *mWalletServiceMockGetHistory) Calls() []*WalletServiceMockGetHistoryParams {
	mmGetHistory.mutex.RLock()

	argCopy := make([]*WalletServiceMockGetHistoryParams, len(mmGetHistory.callArgs))
	copy(argCopy, mmGetHistory.callArgs)

	mmGetHistory.mutex.RUnlock()

	return argCopy
}

// MinimockGetHistoryDone returns true if the count of the GetHistory invocations corresponds
// the number of defined expectations
func (m *WalletServiceMock) MinimockGetHistoryDone() bool {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetHistoryInspect logs each unmet expectation
func (m *WalletServiceMock) MinimockGetHistoryInspect() {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WalletServiceMock.GetHistory with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		if m.GetHistoryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WalletServiceMock.GetHistory")
		} else {
			m.t.Errorf("Expected call to WalletServiceMock.GetHistory with params: %#v", *m.GetHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		m.t.Error("Expected call to WalletServiceMock.GetHistory")
	}
}

type mWalletServiceMockGetWallet struct {
	mock               *WalletServiceMock
	defaultExpectation *WalletServiceMockGetWalletExpectation
	expectations       []*WalletServiceMockGetWalletExpectation

	callArgs []*WalletServiceMockGetWalletParams
	mutex    sync.RWMutex
}

// WalletServiceMockGetWalletExpectation specifies expectation struct of the WalletService.GetWallet
type WalletServiceMockGetWalletExpectation struct {
	mock    *WalletServiceMock
	params  *WalletServiceMockGetWalletParams
	results *WalletServiceMockGetWalletResults
	Counter uint64
}

// WalletServiceMockGetWalletParams contains parameters of the WalletService.GetWallet
type WalletServiceMockGetWalletParams struct {
	ctx context.Context
	id  string
}

// WalletServiceMockGetWalletResults contains results of the WalletService.GetWallet
type WalletServiceMockGetWalletResults struct {
	wp1 *model.Wallet
	err error
}

// Expect sets up expected params for WalletService.GetWallet
func (mmGetWallet *mWalletServiceMockGetWallet) Expect(ctx context.Context, id string) *mWalletServiceMockGetWallet {
	if mmGetWallet.mock.funcGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("WalletServiceMock.GetWallet mock is already set by Set")
	}

	if mmGetWallet.defaultExpectation == nil {
		mmGetWallet.defaultExpectation = &WalletServiceMockGetWalletExpectation{}
	}

	mmGetWallet.defaultExpectation.params = &WalletServiceMockGetWalletParams{ctx, id}
	for _, e := range mmGetWallet.expectations {
		if minimock.Equal(e.params, mmGetWallet.defaultExpectation.params) {
			mmGetWallet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWallet.defaultExpectation.params)
		}
	}

	return mmGetWallet
}

// Inspect accepts an inspector function that has same arguments as the WalletService.GetWallet
func (mmGetWallet *mWalletServiceMockGetWallet) Inspect(f func(ctx context.Context, id string)) *mWalletServiceMockGetWallet {
	if mmGetWallet.mock.inspectFuncGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("Inspect function is already set for WalletServiceMock.GetWallet")
	}

	mmGetWallet.mock.inspectFuncGetWallet = f

	return mmGetWallet
}

// Return sets up results that will be returned by WalletService.GetWallet
func (mmGetWallet *mWalletServiceMockGetWallet) Return(wp1 *model.Wallet, err error) *WalletServiceMock {
	if mmGetWallet.mock.funcGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("WalletServiceMock.GetWallet mock is already set by Set")
	}

	if mmGetWallet.defaultExpectation == nil {
		mmGetWallet.defaultExpectation = &WalletServiceMockGetWalletExpectation{mock: mmGetWallet.mock}
	}
	mmGetWallet.defaultExpectation.results = &WalletServiceMockGetWalletResults{wp1, err}
	return mmGetWallet.mock
}

// Set uses given function f to mock the WalletService.GetWallet method
func (mmGetWallet *mWalletServiceMockGetWallet) Set(f func(ctx context.Context, id string) (wp1 *model.Wallet, err error)) *WalletServiceMock {
	if mmGetWallet.defaultExpectation != nil {
		mmGetWallet.mock.t.Fatalf("Default expectation is already set for the WalletService.GetWallet method")
	}

	if len(mmGetWallet.expectations) > 0 {
		mmGetWallet.mock.t.Fatalf("Some expectations are already set for the WalletService.GetWallet method")
	}

	mmGetWallet.mock.funcGetWallet = f
	return mmGetWallet.mock
}

// When sets expectation for the WalletService.GetWallet which will trigger the result defined by the following
// Then helper
func (mmGetWallet *mWalletServiceMockGetWallet) When(ctx context.Context, id string) *WalletServiceMockGetWalletExpectation {
	if mmGetWallet.mock.funcGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("WalletServiceMock.GetWallet mock is already set by Set")
	}

	expectation := &WalletServiceMockGetWalletExpectation{
		mock:   mmGetWallet.mock,
		params: &WalletServiceMockGetWalletParams{ctx, id},
	}
	mmGetWallet.expectations = append(mmGetWallet.expectations, expectation)
	return expectation
}

// Then sets up WalletService.GetWallet return parameters for the expectation previously defined by the When method
func (e *WalletServiceMockGetWalletExpectation) Then(wp1 *model.Wallet, err error) *WalletServiceMock {
	e.results = &WalletServiceMockGetWalletResults{wp1, err}
	return e.mock
}

// GetWallet implements service.WalletService
func (mmGetWallet *WalletServiceMock) GetWallet(ctx context.Context, id string) (wp1 *model.Wallet, err error) {
	mm_atomic.AddUint64(&mmGetWallet.beforeGetWalletCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWallet.afterGetWalletCounter, 1)

	if mmGetWallet.inspectFuncGetWallet != nil {
		mmGetWallet.inspectFuncGetWallet(ctx, id)
	}

	mm_params := WalletServiceMockGetWalletParams{ctx, id}

	// Record call args
	mmGetWallet.GetWalletMock.mutex.Lock()
	mmGetWallet.GetWalletMock.callArgs = append(mmGetWallet.GetWalletMock.callArgs, &mm_params)
	mmGetWallet.GetWalletMock.mutex.Unlock()

	for _, e := range mmGetWallet.GetWalletMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp1, e.results.err
		}
	}

	if mmGetWallet.GetWalletMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWallet.GetWalletMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWallet.GetWalletMock.defaultExpectation.params
		mm_got := WalletServiceMockGetWalletParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWallet.t.Errorf("WalletServiceMock.GetWallet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWallet.GetWalletMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWallet.t.Fatal("No results are set for the WalletServiceMock.GetWallet")
		}
		return (*mm_results).wp1, (*mm_results).err
	}
	if mmGetWallet.funcGetWallet != nil {
		return mmGetWallet.funcGetWallet(ctx, id)
	}
	mmGetWallet.t.Fatalf("Unexpected call to WalletServiceMock.GetWallet. %v %v", ctx, id)
	return
}

// GetWalletAfterCounter returns a count of finished WalletServiceMock.GetWallet invocations
func (mmGetWallet *WalletServiceMock) GetWalletAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWallet.afterGetWalletCounter)
}

// GetWalletBeforeCounter returns a count of WalletServiceMock.GetWallet invocations
func (mmGetWallet *WalletServiceMock) GetWalletBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWallet.beforeGetWalletCounter)
}

// Calls returns a list of arguments used in each call to WalletServiceMock.GetWallet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWallet *mWalletServiceMockGetWallet) Calls() []*WalletServiceMockGetWalletParams {
	mmGetWallet.mutex.RLock()

	argCopy := make([]*WalletServiceMockGetWalletParams, len(mmGetWallet.callArgs))
	copy(argCopy, mmGetWallet.callArgs)

	mmGetWallet.mutex.RUnlock()

	return argCopy
}

// MinimockGetWalletDone returns true if the count of the GetWallet invocations corresponds
// the number of defined expectations
func (m *WalletServiceMock) MinimockGetWalletDone() bool {
	for _, e := range m.GetWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWallet != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWalletInspect logs each unmet expectation
func (m *WalletServiceMock) MinimockGetWalletInspect() {
	for _, e := range m.GetWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WalletServiceMock.GetWallet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		if m.GetWalletMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WalletServiceMock.GetWallet")
		} else {
			m.t.Errorf("Expected call to WalletServiceMock.GetWallet with params: %#v", *m.GetWalletMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWallet != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		m.t.Error("Expected call to WalletServiceMock.GetWallet")
	}
}

type mWalletServiceMockSendMoney struct {
	mock               *WalletServiceMock
	defaultExpectation *WalletServiceMockSendMoneyExpectation
	expectations       []*WalletServiceMockSendMoneyExpectation

	callArgs []*WalletServiceMockSendMoneyParams
	mutex    sync.RWMutex
}

// WalletServiceMockSendMoneyExpectation specifies expectation struct of the WalletService.SendMoney
type WalletServiceMockSendMoneyExpectation struct {
	mock    *WalletServiceMock
	params  *WalletServiceMockSendMoneyParams
	results *WalletServiceMockSendMoneyResults
	Counter uint64
}

// WalletServiceMockSendMoneyParams contains parameters of the WalletService.SendMoney
type WalletServiceMockSendMoneyParams struct {
	ctx   context.Context
	trans *model.Transfer
}

// WalletServiceMockSendMoneyResults contains results of the WalletService.SendMoney
type WalletServiceMockSendMoneyResults struct {
	err error
}

// Expect sets up expected params for WalletService.SendMoney
func (mmSendMoney *mWalletServiceMockSendMoney) Expect(ctx context.Context, trans *model.Transfer) *mWalletServiceMockSendMoney {
	if mmSendMoney.mock.funcSendMoney != nil {
		mmSendMoney.mock.t.Fatalf("WalletServiceMock.SendMoney mock is already set by Set")
	}

	if mmSendMoney.defaultExpectation == nil {
		mmSendMoney.defaultExpectation = &WalletServiceMockSendMoneyExpectation{}
	}

	mmSendMoney.defaultExpectation.params = &WalletServiceMockSendMoneyParams{ctx, trans}
	for _, e := range mmSendMoney.expectations {
		if minimock.Equal(e.params, mmSendMoney.defaultExpectation.params) {
			mmSendMoney.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMoney.defaultExpectation.params)
		}
	}

	return mmSendMoney
}

// Inspect accepts an inspector function that has same arguments as the WalletService.SendMoney
func (mmSendMoney *mWalletServiceMockSendMoney) Inspect(f func(ctx context.Context, trans *model.Transfer)) *mWalletServiceMockSendMoney {
	if mmSendMoney.mock.inspectFuncSendMoney != nil {
		mmSendMoney.mock.t.Fatalf("Inspect function is already set for WalletServiceMock.SendMoney")
	}

	mmSendMoney.mock.inspectFuncSendMoney = f

	return mmSendMoney
}

// Return sets up results that will be returned by WalletService.SendMoney
func (mmSendMoney *mWalletServiceMockSendMoney) Return(err error) *WalletServiceMock {
	if mmSendMoney.mock.funcSendMoney != nil {
		mmSendMoney.mock.t.Fatalf("WalletServiceMock.SendMoney mock is already set by Set")
	}

	if mmSendMoney.defaultExpectation == nil {
		mmSendMoney.defaultExpectation = &WalletServiceMockSendMoneyExpectation{mock: mmSendMoney.mock}
	}
	mmSendMoney.defaultExpectation.results = &WalletServiceMockSendMoneyResults{err}
	return mmSendMoney.mock
}

// Set uses given function f to mock the WalletService.SendMoney method
func (mmSendMoney *mWalletServiceMockSendMoney) Set(f func(ctx context.Context, trans *model.Transfer) (err error)) *WalletServiceMock {
	if mmSendMoney.defaultExpectation != nil {
		mmSendMoney.mock.t.Fatalf("Default expectation is already set for the WalletService.SendMoney method")
	}

	if len(mmSendMoney.expectations) > 0 {
		mmSendMoney.mock.t.Fatalf("Some expectations are already set for the WalletService.SendMoney method")
	}

	mmSendMoney.mock.funcSendMoney = f
	return mmSendMoney.mock
}

// When sets expectation for the WalletService.SendMoney which will trigger the result defined by the following
// Then helper
func (mmSendMoney *mWalletServiceMockSendMoney) When(ctx context.Context, trans *model.Transfer) *WalletServiceMockSendMoneyExpectation {
	if mmSendMoney.mock.funcSendMoney != nil {
		mmSendMoney.mock.t.Fatalf("WalletServiceMock.SendMoney mock is already set by Set")
	}

	expectation := &WalletServiceMockSendMoneyExpectation{
		mock:   mmSendMoney.mock,
		params: &WalletServiceMockSendMoneyParams{ctx, trans},
	}
	mmSendMoney.expectations = append(mmSendMoney.expectations, expectation)
	return expectation
}

// Then sets up WalletService.SendMoney return parameters for the expectation previously defined by the When method
func (e *WalletServiceMockSendMoneyExpectation) Then(err error) *WalletServiceMock {
	e.results = &WalletServiceMockSendMoneyResults{err}
	return e.mock
}

// SendMoney implements service.WalletService
func (mmSendMoney *WalletServiceMock) SendMoney(ctx context.Context, trans *model.Transfer) (err error) {
	mm_atomic.AddUint64(&mmSendMoney.beforeSendMoneyCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMoney.afterSendMoneyCounter, 1)

	if mmSendMoney.inspectFuncSendMoney != nil {
		mmSendMoney.inspectFuncSendMoney(ctx, trans)
	}

	mm_params := WalletServiceMockSendMoneyParams{ctx, trans}

	// Record call args
	mmSendMoney.SendMoneyMock.mutex.Lock()
	mmSendMoney.SendMoneyMock.callArgs = append(mmSendMoney.SendMoneyMock.callArgs, &mm_params)
	mmSendMoney.SendMoneyMock.mutex.Unlock()

	for _, e := range mmSendMoney.SendMoneyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMoney.SendMoneyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMoney.SendMoneyMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMoney.SendMoneyMock.defaultExpectation.params
		mm_got := WalletServiceMockSendMoneyParams{ctx, trans}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMoney.t.Errorf("WalletServiceMock.SendMoney got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMoney.SendMoneyMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMoney.t.Fatal("No results are set for the WalletServiceMock.SendMoney")
		}
		return (*mm_results).err
	}
	if mmSendMoney.funcSendMoney != nil {
		return mmSendMoney.funcSendMoney(ctx, trans)
	}
	mmSendMoney.t.Fatalf("Unexpected call to WalletServiceMock.SendMoney. %v %v", ctx, trans)
	return
}

// SendMoneyAfterCounter returns a count of finished WalletServiceMock.SendMoney invocations
func (mmSendMoney *WalletServiceMock) SendMoneyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMoney.afterSendMoneyCounter)
}

// SendMoneyBeforeCounter returns a count of WalletServiceMock.SendMoney invocations
func (mmSendMoney *WalletServiceMock) SendMoneyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMoney.beforeSendMoneyCounter)
}

// Calls returns a list of arguments used in each call to WalletServiceMock.SendMoney.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMoney *mWalletServiceMockSendMoney) Calls() []*WalletServiceMockSendMoneyParams {
	mmSendMoney.mutex.RLock()

	argCopy := make([]*WalletServiceMockSendMoneyParams, len(mmSendMoney.callArgs))
	copy(argCopy, mmSendMoney.callArgs)

	mmSendMoney.mutex.RUnlock()

	return argCopy
}

// MinimockSendMoneyDone returns true if the count of the SendMoney invocations corresponds
// the number of defined expectations
func (m *WalletServiceMock) MinimockSendMoneyDone() bool {
	for _, e := range m.SendMoneyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMoneyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMoneyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMoney != nil && mm_atomic.LoadUint64(&m.afterSendMoneyCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMoneyInspect logs each unmet expectation
func (m *WalletServiceMock) MinimockSendMoneyInspect() {
	for _, e := range m.SendMoneyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WalletServiceMock.SendMoney with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMoneyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMoneyCounter) < 1 {
		if m.SendMoneyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WalletServiceMock.SendMoney")
		} else {
			m.t.Errorf("Expected call to WalletServiceMock.SendMoney with params: %#v", *m.SendMoneyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMoney != nil && mm_atomic.LoadUint64(&m.afterSendMoneyCounter) < 1 {
		m.t.Error("Expected call to WalletServiceMock.SendMoney")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WalletServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateWalletInspect()

			m.MinimockGetHistoryInspect()

			m.MinimockGetWalletInspect()

			m.MinimockSendMoneyInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WalletServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WalletServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateWalletDone() &&
		m.MinimockGetHistoryDone() &&
		m.MinimockGetWalletDone() &&
		m.MinimockSendMoneyDone()
}
